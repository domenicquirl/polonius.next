typedef Origin = istring
typedef Node = istring

/////////////////////////////////////////////
// Inputs
//
// ## Assumptions about ordering
// 
// For a given node `N`...
// 
// * First we perform any accesses `AccessOrigin(O, N)`
// * Then we invalidate any origins `InvalidateOrigin(L, N)`
// * Then we clear any origins `ClearOrigin`
// * Then we introduce any subsets `IntroduceSubset`
// 
// This corresponds to 
// 
// ```
// place = expr
// ```
// 
// * Evaluating the expr accesses the origins (including potentially some in place)
// * Then place is overwritten, invalidating and clearing loans
// * Storing the value also creates subtyping relationships between the type of the value that was stored and the place it was stored into
//
// ## Rules to generate inputs:
//
// * For each place `P` that is read, generate `AccessOrigin`...
//     * for each origin in the type of `P`
//     * for the origin of each reference that is deref'd in `P`
//          * e.g., `read((*x).0)` where `x: &'x0 (&'x1 u32, &'x2 u32)` would generate
//              * `AccessOrigin('x0)` because of the `*`
//              * `AccessOrigin('x1)` because the final type of `(*x).0` is `&'x1 u32`
// * Generate `InvalidateOrigin` for each loan origin that is invalidated by reads/writes
//     * e.g., if the expression reads `x`, and there is a mut borrow `'L_mut_x` of `x`, then we would generate
//       `InvalidateOrigin('L_mut_x)`
// * Generate `ClearOrigin` for each loan origin that is cleared by reads/writes
//     * e.g., if there is a loan `'L_*temp` where `temp: &T` and this expression writes to `temp`, then `'L_*temp` is cleared,
//       not invalidated. This is because memory at `*temp` is not owned, so it is not freed by writing to `temp`,
//       but `*temp` no longer names the same memory anymore.
// * For every `&'L_P P` expression, generate `ClearOrigin('L_P)` 
// * If this is a `&'L_P P` for some place `P`, it is treated as a read of the place `P`:
//     * In addition, "unroll" P to add subset relations:
//          * If `P = *Q` where `Q: &'O T`, then `'L_P <= O` (do not continue unrolling)
//          * If `P = *Q` where `Q: &'O mut T`, then `'L_P <= O` and continue "unrolling" `Q`
//          * Why do we continue only with `&mut`? The path we took to reach a `&` not important; the ref could just
//            be copied out anyway. For `&mut` that path *is* important, because once we finish with our loan,
//            it can be used to perform mutation again. We need to ensure that we remember the path we came from.
// * If this is a `&'L_mut_P mut P` for some place `P`, it is treated as a write of the place `P`:
//     * In addition, "unroll" P to add subset relations:
//          * If `P = *Q` where `Q: &'O T`, then error (mut borrow of shared content)
//          * If `P = *Q` where `Q: &'O mut T`, then `'L_P <= O` and continue "unrolling" `Q`
// * Generate `IntroduceSubset` for subsets that arise from where-clauses or subtyping on this node

// marks the origin `o` as a loan origin
input relation MarkAsLoanOrigin(o: Origin)

// AccessOrigin data with origin `o` at node `n`
input relation AccessOrigin(o: Origin, n: Node)

// Invalidate the origin `o` at the node `n`
input relation InvalidateOrigin(o: Origin, n: Node)

// All references with origin `o` are overwritten at node `n`
input relation ClearOrigin(o: Origin, n: Node)

// Require that `o1 <= o2` at node `n`
input relation IntroduceSubset(o1: Origin, o2: Origin, n: Node)

// Control-flow graph edge `n1 -> n2`
input relation CfgEdge(n1: Node, n2: Node)

/////////////////////////////////////////////
output relation ClearedAtNode(origins: Set<Origin>, n: Node)

// Individual clears
ClearedAtNode(set_singleton(o), n) :- 
  ClearOrigin(o, n).

// No clears at a node
ClearedAtNode(set_empty(), n) :-
  CfgEdge(n, _),
  not ClearOrigin(_, n).
ClearedAtNode(set_empty(), n) :-
  CfgEdge(_, n),
  not ClearOrigin(_, n).

// Union
ClearedAtNode(s, n) :-
  ClearedAtNode(s1, n),
  ClearedAtNode(s2, n),
  var s = union(s1, s2).

/////////////////////////////////////////////
output relation SubsetIfLiveOnExit(o1: Origin, o2: Origin, if_live: Set<Origin>, seen: Set<Origin>, valid_at: Node, n: Node)

// Carried over within node, filtered for clears
SubsetIfLiveOnExit(o1, o2, l, s, source, n) :- 
  SubsetIfLiveOnEntry(o1, o2, l, s, source, n),
  not ClearOrigin(o1, n),
  not ClearOrigin(o2, n),
  // Origins in l\s are yet to be seen to be accessed to count as live.
  // If such an origin is cleared, it is cleared before the access, and thus not live.
  // Hence, the condition for this subset cannot be satisfied anymore.
  ClearedAtNode(origins, n),
  is_empty(intersection(origins, difference(l, s))). 

/////////////////////////////////////////////
output relation SubsetIfLiveOnEntry(o1: Origin, o2: Origin, if_live: Set<Origin>, seen: Set<Origin>, valid_at: Node, n: Node)

// Carried over from predecessor.
SubsetIfLiveOnEntry(o1, o2, l, s, valid_at, n2) :- 
  CfgEdge(n1, n2),
  SubsetIfLiveOnExit(o1, o2, l, s, valid_at, n1). 
// Subsets that are live at our predecessor will need to be checked again at the successor
SubsetIfLiveOnEntry(o1, o2, l, set_empty(), n2, n2) :- 
  CfgEdge(n1, n2),
  SubsetOnExit(o1, o2, n1),
  not MarkAsLoanOrigin(o1),
  not AccessOrigin(o1, n2),
  not MarkAsLoanOrigin(o2),
  not AccessOrigin(o2, n2),
  var l = union(set_singleton(o1), set_singleton(o2)).
SubsetIfLiveOnEntry(o1, o2, set_singleton(o2), set_empty(), n2, n2) :- 
  MarkAsLoanOrigin(o1),
  CfgEdge(n1, n2),
  SubsetOnExit(o1, o2, n1),
  not MarkAsLoanOrigin(o2),
  not AccessOrigin(o2, n2).
SubsetIfLiveOnEntry(o1, o2, set_singleton(o2), set_empty(), n2, n2) :- 
  AccessOrigin(o1, n2),
  CfgEdge(n1, n2),
  SubsetOnExit(o1, o2, n1),
  not MarkAsLoanOrigin(o2),
  not AccessOrigin(o2, n2).
SubsetIfLiveOnEntry(o1, o2, set_singleton(o1), set_empty(), n2, n2) :- 
  MarkAsLoanOrigin(o2),
  CfgEdge(n1, n2),
  SubsetOnExit(o1, o2, n1),
  not MarkAsLoanOrigin(o1),
  not AccessOrigin(o1, n2).
SubsetIfLiveOnEntry(o1, o2, set_singleton(o1), set_empty(), n2, n2) :- 
  AccessOrigin(o2, n2),
  CfgEdge(n1, n2),
  SubsetOnExit(o1, o2, n1),
  not MarkAsLoanOrigin(o1),
  not AccessOrigin(o1, n2).

// Accumulate accesses
SubsetIfLiveOnEntry(o1, o2, l, new_s, valid_at, n) :- 
  SubsetIfLiveOnEntry(o1, o2, l, s, valid_at, n),
  AccessOrigin(o, n),
  contains(l, o),
  var new_s = set_union(s, set_singleton(o)).
SubsetIfLiveOnEntry(o1, o2, l, new_s, valid_at, n) :- 
  SubsetIfLiveOnEntry(o1, o2, l, s, valid_at, n),
  AccessOrigin(o, n),
  contains(l, o),
  var new_s = set_union(s, set_singleton(o)).

/////////////////////////////////////////////
output relation SubsetOnExit(o1: Origin, o2: Origin, n: Node)

// New subsets 
SubsetOnExit(o1, o2, n) :- 
  IntroduceSubset(o1, o2, n).

// Filter out clears
SubsetOnExit(o1, o2, n) :- 
  SubsetOnEntry(o1, o2, n),
  not ClearOrigin(o1, n),
  not ClearOrigin(o2, n).

// Activated because they are now live.
SubsetOnExit(o1, o2, valid_at) :- 
  SubsetIfLiveOnExit(o1, o2, l, s, valid_at, _),
  l == s.

// Transitive closure
SubsetOnExit(o1, o3, n) :- 
  SubsetOnExit(o1, o2, n),
  SubsetOnExit(o2, o3, n),
  o1 != o3.

/////////////////////////////////////////////
output relation SubsetOnEntry(o1: Origin, o2: Origin, n: Node) 

// Immediately active
SubsetOnEntry(o1, o2, n2) :- 
  AccessOrigin(o1, n2),
  AccessOrigin(o2, n2),
  SubsetOnExit(o1, o2, n1),
  CfgEdge(n1, n2).
SubsetOnEntry(o1, o2, n2) :- 
  MarkAsLoanOrigin(o1),
  AccessOrigin(o2, n2),
  SubsetOnExit(o1, o2, n1),
  CfgEdge(n1, n2).
SubsetOnEntry(o1, o2, n2) :- 
  AccessOrigin(o1, n2),
  MarkAsLoanOrigin(o2),
  SubsetOnExit(o1, o2, n1),
  CfgEdge(n1, n2).
SubsetOnEntry(o1, o2, n2) :- 
  MarkAsLoanOrigin(o1),
  MarkAsLoanOrigin(o2),
  SubsetOnExit(o1, o2, n1),
  CfgEdge(n1, n2).

// Activated because they are now live.
SubsetOnEntry(o1, o2, valid_at) :- 
  SubsetIfLiveOnEntry(o1, o2, l, s, valid_at, _),
  l == s.

////////////////////////////////////////////
output relation OriginInvalidatedIfLive(o: Origin, if_live: Set<Origin>, seen: Set<Origin>, valid_at: Node, n: Node)

// Carried over from predecessor, filtered for clears
OriginInvalidatedIfLive(o, l, s, valid_at, n2) :- 
  CfgEdge(n1, n2), 
  OriginInvalidatedIfLive(o, l, s, valid_at, n1),
  not ClearOrigin(o, n1),
  // Origins in l\s are yet to be seen to be accessed to count as live.
  // If such an origin is cleared, it is cleared before the access, and thus not live.
  // Hence, the condition for this subset cannot be satisfied anymore.
  ClearedAtNode(origins, n1),
  is_empty(intersection(origins, difference(l, s))). 

// Because invalidations conceptually happen before clears, 
// propagate them across (existing, not introduced) subset relationships
// even if `o1` is also (conceptually later) cleared in `n1`.
OriginInvalidatedIfLive(o2, l, s, n2, n2) :- 
  CfgEdge(n1, n2),
  SubsetIfLiveOnEntry(o1, o2, l, s, n1, n1),
  not ClearOrigin(o2, n1),
  InvalidateOrigin(o1, n1).

// Accumulate accesses
OriginInvalidatedIfLive(o, l, new_s, valid_at, n) :- 
  OriginInvalidatedIfLive(o, l, s, valid_at, n),
  AccessOrigin(orig, n),
  contains(l, orig),
  var new_s = set_union(s, set_singleton(orig)).
OriginInvalidatedIfLive(o, l, new_s, valid_at, n) :- 
  OriginInvalidatedIfLive(o, l, s, valid_at, n),
  AccessOrigin(orig, n),
  contains(l, orig),
  var new_s = set_union(s, set_singleton(orig)).

////////////////////////////////////////////
output relation OriginInvalidated(o: Origin, n: Node)

OriginInvalidated(o, n2) :- // Introduced by predecessor
  CfgEdge(n1, n2),
  InvalidateOrigin(o, n1),
  not ClearOrigin(o, n1).
OriginInvalidated(o, n2) :- // Introduced by predecessor
  CfgEdge(n1, n2),
  OriginInvalidated(o, n1),
  not ClearOrigin(o, n1).

// Activated because they are now live.
OriginInvalidated(o, valid_at) :- 
  OriginInvalidatedIfLive(o, l, s, valid_at, _),
  l == s.

// Because invalidations conceptually happen before clears, 
// propagate them across (existing, not introduced) subset relationships
// even if `o1` is also (conceptually later) cleared in `n1`.
OriginInvalidated(o2, n2) :- 
  CfgEdge(n1, n2),
  SubsetOnEntry(o1, o2, n1),
  not ClearOrigin(o2, n1),
  InvalidateOrigin(o1, n1).

/////////////////////////////////////////////////////
output relation InvalidatedOriginAccessed(o: Origin, n: Node)

InvalidatedOriginAccessed(o, n) :- // Introduced by predecessor
  AccessOrigin(o, n),
  OriginInvalidated(o, n).

